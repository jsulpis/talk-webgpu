---
import Layout from "../../layouts/Layout.astro";
---

<script>
  import * as THREE from "three";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { clone } from "three/addons/utils/SkeletonUtils.js";
  import { computePositions, computeVelocities } from "../../three/gpgpu";
  import { canvasBackground } from "../../shared";

  const BOUNDS = 30;
  const speed = 0.008;

  const boidsUniforms = {
    deltaTime: 0,
    separationDistance: 10,
    alignmentDistance: 50,
    cohesionDistance: 50,
    borderForce: 0.3,
    borderDistance: 50,
    bounds: BOUNDS,
  };

  const modelUrl = "/Fish.glb";

  const COUNT = 10;

  document.getElementById("objects")!.innerText = COUNT.toString();

  const models: THREE.Object3D[] = [];

  /******************************************************************* */
  /***************************** GPGPU *********************************/
  /******************************************************************* */

  let positionsBufferA = new Float32Array(COUNT * 3);
  positionsBufferA[0] = 0;
  positionsBufferA[1] = 0;
  positionsBufferA[2] = BOUNDS / 2;

  for (let i = 3; i < positionsBufferA.length; i += 3) {
    positionsBufferA[i + 0] = (Math.random() + 0.5) * BOUNDS * 4;
    positionsBufferA[i + 1] = (Math.random() + 0.5) * BOUNDS * 4;
    positionsBufferA[i + 2] = (Math.random() + 0.5) * BOUNDS * 4;
  }
  let positionsBufferB = new Float32Array(COUNT * 3);

  const positionsBuffers = {
    read: positionsBufferA,
    write: positionsBufferB,
  };

  function swapPositionsBuffers() {
    const temp = positionsBuffers.read;
    positionsBuffers.read = positionsBuffers.write;
    positionsBuffers.write = temp;
  }

  let velocityBufferA = new Float32Array(COUNT * 3);
  velocityBufferA[0] = 2;
  velocityBufferA[1] = 1;
  velocityBufferA[2] = 0;
  for (let i = 3; i < velocityBufferA.length; i += 3) {
    velocityBufferA[i + 0] = Math.random();
    velocityBufferA[i + 1] = Math.random();
    velocityBufferA[i + 2] = Math.random();
  }
  let velocityBufferB = new Float32Array(COUNT * 3);

  const velocityBuffers = {
    read: velocityBufferA,
    write: velocityBufferB,
  };

  function swapVelocityBuffers() {
    const temp = velocityBuffers.read;
    velocityBuffers.read = velocityBuffers.write;
    velocityBuffers.write = temp;
  }

  function moveModels(positions: Float32Array, velocities: Float32Array) {
    models.forEach((model, i) => {
      model.position.x = positions[i * 3 + 0];
      model.position.y = positions[i * 3 + 1];
      model.position.z = positions[i * 3 + 2];

      model.lookAt(
        model.position.x + velocities[i * 3 + 0],
        model.position.y + velocities[i * 3 + 1],
        model.position.z + velocities[i * 3 + 2]
      );
    });
  }

  /****************************************************************** */
  /***************************** INIT *********************************/
  /****************************************************************** */

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(...canvasBackground.slice(0, 3));

  let mixer: THREE.AnimationMixer;

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.z = BOUNDS * 3;

  const geometry = new THREE.BoxGeometry(BOUNDS * 2, BOUNDS * 2, BOUNDS * 2);
  const material = new THREE.MeshBasicMaterial({
    color: 0x0000ff,
    wireframe: true,
  });
  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector("canvas")!, antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setAnimationLoop(animate);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;

  const ambientLight = new THREE.AmbientLight(0xffffff, 1);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
  directionalLight.position.set(1, 1, 1).normalize();
  scene.add(directionalLight);

  loadModel();

  window.addEventListener("resize", onWindowResize);

  function loadModel() {
    const loader = new GLTFLoader();
    loader.load(modelUrl, function (gltf) {
      const model = gltf.scene;
      scene.add(model);
      models.push(model);

      mixer = new THREE.AnimationMixer(model);
      let action = mixer.clipAction(gltf.animations[0]);
      action.play();

      for (let i = 1; i < COUNT; i++) {
        const clonedModel = clone(model);
        models.push(clonedModel);

        getMaterial(clonedModel).color = new THREE.Color(0, 0.6 + Math.random() * 0.4, 0.6 + Math.random() * 0.4);
        scene.add(clonedModel);
      }

      getMesh(model).material = new THREE.MeshStandardMaterial({
        color: "red",
      });
    });
  }

  function getMesh(gltfModel: THREE.Object3D): THREE.Mesh {
    return gltfModel.children[0].children[0].children[0] as THREE.Mesh;
  }

  function getMaterial(gltfModel: THREE.Object3D): THREE.MeshStandardMaterial {
    return getMesh(gltfModel).material as THREE.MeshStandardMaterial;
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  /********************************************************************* */
  /***************************** ANIMATE *********************************/
  /********************************************************************* */

  const renderElement = document.getElementById("render")!;
  const computeElement = document.getElementById("compute")!;

  const clock = new THREE.Clock();

  function animate() {
    controls.update();
    const deltaTime = clock.getDelta() * 1000 * speed;

    performance.mark("compute");

    computeVelocities(
      velocityBuffers.read,
      velocityBuffers.write,
      positionsBuffers.read,
      deltaTime,
      boidsUniforms.separationDistance,
      boidsUniforms.alignmentDistance,
      boidsUniforms.cohesionDistance,
      true
    );
    swapVelocityBuffers();

    computePositions(positionsBuffers.read, positionsBuffers.write, velocityBuffers.read, deltaTime);
    swapPositionsBuffers();

    const compute = performance.measure("compute", "compute");
    computeElement.textContent = compute.duration.toFixed(2) + "ms";

    moveModels(positionsBuffers.read, velocityBuffers.read);

    mixer?.update(clock.getDelta() * 300);

    performance.mark("render");
    renderer.render(scene, camera);
    const render = performance.measure("render", "render");
    renderElement.textContent = render.duration.toFixed(2) + "ms";
  }
</script>

<Layout api="WebGL" />
